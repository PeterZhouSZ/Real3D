#version 400

uniform mat4 mvMatrix;
uniform mat4 pMatrix;
uniform mat3 normalMatrix; //mv matrix without translation

uniform vec4 lightPosition_camSpace; //light Position in camera space

in vec4 vertex_worldSpace;
in vec3 normal_worldSpace;
in vec2 textureCoordinates_input;

out vec3 varyingNormal_camSpace;
out vec3 varyingLightDirection_camSpace;
out vec3 varyingViewingDirection_camSpace;
out vec2 varyingTextureCoordinates;

//Vertex shader compute the vectors per vertex
void main(void)
{
    //Put the vertex in the correct coordinate system by applying the model view matrix
    vec4 vertex_camSpace = mvMatrix*vertex_worldSpace;
	
    //Apply the model-view transformation to the normal (only rotation, no transloation)
    //Normals put in the view space
    varyingNormal_camSpace = normalMatrix*normal_worldSpace;

    //Direction of the light source : omega_i vector
    //Light direction and eyeVertex are in the camera space
    varyingLightDirection_camSpace = lightPosition_camSpace.xyz-vertex_camSpace.xyz;

    //Direction of the camera : omega_o vector
    //omega_o = positionCamera-vertex but positionCamera is (0,0,0) in the coordinate system of the camera
    varyingViewingDirection_camSpace = -vertex_camSpace.xyz;
	
	varyingTextureCoordinates = textureCoordinates_input;
	
    gl_Position = pMatrix * vertex_camSpace;
}
